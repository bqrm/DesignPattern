/***************************************************
 * @file		GenerateCallbackThread.h
 * @section		
 * @class		CGenerateCallbackThread
 * @brief		generate event, call callback to process
 * @author		bqrmtao@gmail.com
 * @date		2018/07/12
 * @version		1.0
 * @copyright	bqrmtao@gmail.com
***************************************************/

#ifndef __GENERATE_CALLBACK_THREAD__
#define __GENERATE_CALLBACK_THREAD__

#include <windows.h>

#include "CallbackImp.h"
#include "CallbackKeeper.h"
#include "ThreadStd.h"

/* enum */
//enum 
//{
//		,   ///< 
//};

/*
 * @class	CGenerateCallbackThread
 * @brief	generating callback event
*/
class CGenerateCallbackThread : public IThreadStd
{
public:
	/*
	 * @brief	constructor
	*/
	CGenerateCallbackThread() {}
	/*
	 * @brief	destructor
	*/
	~CGenerateCallbackThread() {}
	
	/*
	 * @brief	get name of current thread
	*/
	virtual std::string Name() { return "CGenerateCallbackThread"; }

private:
	/*
	 * @brief	main job of the thread
	*/
	virtual void RunThread()
	{
		int nRoundIdx = 0;
		int nSleepRound = 0;

		CallbackParam sParam;
		sParam.fOprd1 = 5;
		sParam.fOprd2 = 3;

		while (m_isRunning)
		{
			if (m_isActive)
			{
				switch (nRoundIdx % 5)
				{
				case EVENT_ADD:
					printf("event \"EVENT_ADD\" generated by CGenerateCallbackThread\n");
					CCallbackKeeper::GetInstance()->GetCallbackPtr()->ProcessCallback(EVENT_ADD, &sParam);
					break;
				case EVENT_SUB:
					printf("event \"EVENT_SUB\" generated by CGenerateCallbackThread\n");
					CCallbackKeeper::GetInstance()->GetCallbackPtr()->ProcessCallback(EVENT_SUB, &sParam);
					break;
				case EVENT_MUL:
					printf("event \"EVENT_MUL\" generated by CGenerateCallbackThread\n");
					CCallbackKeeper::GetInstance()->GetCallbackPtr()->ProcessCallback(EVENT_MUL, &sParam);
					break;
				case EVENT_DIV:
					printf("event \"EVENT_F_DIV\" generated by CGenerateCallbackThread\n");
					CCallbackKeeper::GetInstance()->GetCallbackPtr()->ProcessCallback(EVENT_DIV, &sParam);
					break;
				case EVENT_MOD:
					printf("event \"EVENT_MOD\" generated by CGenerateCallbackThread\n");
					CCallbackKeeper::GetInstance()->GetCallbackPtr()->ProcessCallback(EVENT_MOD, &sParam);
					break;
				default:
					printf("this branch should never be hit\n");
					break;
				}

				nRoundIdx++;
			}

			SleepThread();
		}
	}
};

/*
 * @brief	
 * @param	
 * @return	
*/

//#ifdef __cplusplus
//extern "C"
//{
//#endif // __cplusplus
//
//
//#ifdef __cplusplus
//};
//#endif // __cplusplus

#endif	// __GENERATE_CALLBACK_THREAD__